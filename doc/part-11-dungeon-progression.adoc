= Dungeon levels and character progression
:icons: font
:source-highlighter: pygments
:source-language: rust
ifdef::env-github[:outfilesuffix: .adoc]


<<index#,Back to the index.>>

What we have now is pretty much a playable game already. The next two
parts will take it a big step forward by focusing on progression.
We'll start with dungeon levels, then character progression and
finally on updating the monster and item placement.

== Second floor please

A staple of roguelikes is the stairs, which the player must find to
advance to the next dungeon level. We will start by placing them, when
generating a level. Right at the end of `make_map`:

[source]
----
// create stairs at the center of the last room
let (last_room_x, last_room_y) = rooms[rooms.len() - 1].center();
let stairs = Object::new(last_room_x, last_room_y, '<', "stairs", colors::WHITE, false);
objects.push(stairs);
----

As you can see, it's just a regular object! We must now let the player
go down the stairs when standing on them and presses the '<' key. It's
easy to add this check at the end of `handle_keys`:

[source]
----
(Key { printable: '<', .. }, true) => {
    // go down stairs, if the player is on them
    let player_on_stairs = objects.iter().any(|object| {
        object.pos() == objects[PLAYER].pos() && object.name == "stairs"
    });
    if player_on_stairs {
        next_level(game, objects, tcod);
        TookTurn
    } else {
        DidntTakeTurn
    }
}
----

The most important bit is the `next_level` function. We need to
generate a brand new level when the player goes down and move player
onto it. We'll also heal the player because we're feeling generous!

[source]
----
/// Advance to the next level
fn next_level(tcod: &mut Tcod, objects: &mut Vec<Object>, game: &mut Game) {
    game.log.add("You take a moment to rest, and recover your strength.", colors::VIOLET);
    objects[PLAYER].fighter.as_mut().map(|f| {
        let heal_hp = f.max_hp / 2;
        f.heal(heal_hp);
    });

    game.log.add("After a rare moment of peace, you descend deeper into \
                  the heart of the dungeon...", colors::RED);
    game.map = make_map(objects);
    initialise_fov(&game.map, &mut tcod.fov);
}
----

You can try it out now. We do generate stairs and let the player go
deeper, but you'll notice that the items and monsters from the old
level are still here -- sometimes lodged in a wall.

The reason we're seeing old objects is because we've never removed
them from the `objects` Vec!

So we need to remove everything except for the Player. Put this in
`make_map` right after we create the empty map:

[source]
----
// Player is the first element, remove everything else.
// NOTE: works only when the player is the first object!
assert_eq!(&objects[PLAYER] as *const _, &objects[0] as *const _);
objects.truncate(1);
----

:truncate: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.truncate

Luckily, {truncate}[Vec has the truncate method], which leaves the
first *n* elements and removes everything else. Since our _player_ is
always the first object in the list, this just works.

The assert is there to make sure that the first object is indeed the
player -- the program will panic otherwise, making sure you address it
if you change your game layout at some point. By the way, this is how
you test for a pointer equivalence in Rust: you convert ordinary Rust
references to raw pointers (`*const Object` in this case) and compare
those. This is safe because we never dereference them. As a bonus, the
compiler can infer the type (`Object`) so you can just say `_` and it
will fill it in.





TODO: talk about keeping track of objects throughout the game

TODO: mention vec::swap if player isn't the first object.



== Character progression

todo




Here's link:part-11-dungeon-progression.rs.txt[the complete code so far].

Continue to <<part-12-monster-item-progression#,the next part>>.
