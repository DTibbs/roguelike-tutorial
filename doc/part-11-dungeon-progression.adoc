= Dungeon levels and character progression
:icons: font
:source-highlighter: pygments
:source-language: rust
ifdef::env-github[:outfilesuffix: .adoc]


<<index#,Back to the index.>>

What we have now is pretty much a playable game already. The next two
parts will take it a big step forward by focusing on progression.
We'll start with dungeon levels, then character progression and
finally on updating the monster and item placement.

== Second floor please

A staple of roguelikes is the stairs, which the player must find to
advance to the next dungeon level. We will start by placing them, when
generating a level. Right at the end of `make_map`:

[source]
----
// create stairs at the center of the last room
let (last_room_x, last_room_y) = rooms[rooms.len() - 1].center();
let stairs = Object::new(last_room_x, last_room_y, '<', "stairs", colors::WHITE, false);
objects.push(stairs);
----

As you can see, it's just a regular object! We must now let the player
go down the stairs when standing on them and presses the '<' key. It's
easy to add this check at the end of `handle_keys`:

[source]
----
(Key { printable: '<', .. }, true) => {
    // go down stairs, if the player is on them
    let player_on_stairs = objects.iter().any(|object| {
        object.pos() == objects[PLAYER].pos() && object.name == "stairs"
    });
    if player_on_stairs {
        next_level(game, objects, tcod);
        TookTurn
    } else {
        DidntTakeTurn
    }
}
----

The most important bit is the `next_level` function. We need to
generate a brand new level when the player goes down and move player
onto it. We'll also heal the player because we're feeling generous!

[source]
----
/// Advance to the next level
fn next_level(tcod: &mut Tcod, objects: &mut Vec<Object>, game: &mut Game) {
    game.log.add("You take a moment to rest, and recover your strength.", colors::VIOLET);
    objects[PLAYER].fighter.as_mut().map(|f| {
        let heal_hp = f.max_hp / 2;
        f.heal(heal_hp);
    });

    game.log.add("After a rare moment of peace, you descend deeper into \
                  the heart of the dungeon...", colors::RED);
    game.map = make_map(objects);
    initialise_fov(&game.map, &mut tcod.fov);
}
----

You can try it out now. We do generate stairs and let the player go
deeper, but you'll notice that the items and monsters from the old
level are still here -- sometimes lodged in a wall.

The reason we're seeing old objects is because we've never removed
them from the `objects` Vec!

So we need to remove everything except for the Player. Put this in
`make_map` right after we create the empty map:

[source]
----
// Player is the first element, remove everything else.
// NOTE: works only when the player is the first object!
assert_eq!(&objects[PLAYER] as *const _, &objects[0] as *const _);
objects.truncate(1);
----

:truncate: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.truncate

Luckily, {truncate}[Vec has the truncate method], which leaves the
first *n* elements and removes everything else. Since our _player_ is
always the first object in the list, this just works.

The assert is there to make sure that the first object is indeed the
player -- the program will panic otherwise, making sure you address it
if you change your game layout at some point. By the way, this is how
you test for a pointer equivalence in Rust: you convert ordinary Rust
references to raw pointers (`*const Object` in this case) and compare
those. This is safe because we never dereference them. As a bonus, the
compiler can infer the type (`Object`) so you can just say `_` and it
will fill it in.

NOTE: If you want to let the player go back up, you may want to keep
track of the map and objects at the previous levels so that they stay
the same.

We'll want to keep track of the dungeon level the player is on. Let's
add a variable to `Game` and set it to one when we start the game and
increase it when we go deeper:

[source]
----
struct Game {
    map: Map,
    log: Messages,
    inventory: Vec<Object>,
    dungeon_level: u32,
}
----

in `new_game`:

[source]
----
let mut game = Game {
    // ...
    dungeon_level: 1,
};
----

and in `next_level` before calling `make_map`:

[source]
----
game.dungeon_level += 1;
----

Now we can display it in the GUI. Add this line to `render_all` after
calling `render_bar`:

[source]
----
tcod.panel.print_ex(1, 3, BackgroundFlag::None, TextAlignment::Left,
                    format!("Dungeon level: {}", game.dungeon_level));
----

Finally, it would be great to always show the stairs once discovered,
so the player can explore the rest of the map before going down. So
let's allow some objects to be always visible as long as they're on a
tile that's already been explored.

We can add `always_visible` to `Object`:

[source]
----
struct Object {
    x: i32,
    y: i32,
    // ...
    always_visible: bool,
}
----

Let's initialise it to `false` in `Object::new`:

[source]
----
pub fn new(x: i32, y: i32, char: char, name: &str, color: Color, blocks: bool) -> Self {
    Object {
        x: x,
        y: y,
        // ...
        always_visible: false,
    }
}
----

Now update `render_all` to take it into account. When building the
`to_draw` vector, let's update the `filter` test to this:

[source]
----
.filter(|o| {
    tcod.fov.is_in_fov(o.x, o.y) ||
        (o.always_visible && game.map[o.x as usize][o.y as usize].explored)
})
----

We keep the old `is_in_fov` test, but now we can also show the object
if it's always visible and on an `explored` tile.

So let's set `always_visible = true` to stairs in `make_map`:

[source]
----
stairs.always_visible = true;
----

you will also have to add `mut` to `let stairs` a line above.

And let's do the same for items, too! In `place_objects` before
`objects.push(item)`.


== Character progression

todo




Here's link:part-11-dungeon-progression.rs.txt[the complete code so far].

Continue to <<part-12-monster-item-progression#,the next part>>.
