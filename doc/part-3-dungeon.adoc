= The Dungeon
:source-highlighter: pygments
ifdef::env-github[:outfilesuffix: .adoc]

<<index#,Back to the index.>>

== Dungeon building blocks

Having a painstakingly handmade room with artfully placed pillars is
all well and good, but roguelikes are about procedural generation! How
about adding some randomness to the mix.

We're going to carve rooms and tunnels in an underground rock. In this
section we'll build some helper functions which we'll then use to
generate the whole dungeon.

First, a struct that will represent a rectangular room:

[source,rust]
----
#[derive(Clone, Copy, Debug)]
struct Rect {
    x1: i32,
    y1: i32,
    x2: i32,
    y2: i32,
}

impl Rect {
    pub fn new(x: i32, y: i32, w: i32, h: i32) -> Self {
        Rect { x1: x, y1: y, x2: x + w, y2: y + h }
    }
}
----

The rectangle stores the coordinates for the top-left and bottom-right
points.

This function will take a rect and place it in the map, by making sure
all the tiles are empty.

[source,rust]
----
fn create_room(room: Rect, map: &mut Map) {
    for x in (room.x1 + 1)..room.x2 {
        for y in (room.y1 + 1)..room.y2 {
            map[x as usize][y as usize] = Tile::empty();
        }
    }
}
----

The `+1` business here is a bit subtle: the `A..B` notation specifies
a range that's inclusive at the beginning but exclusive at the end.
For example `1..5` represents numbers 1, 2, 3 and 4 but *not* 5.

So to go through all the values between `x1` and `x2` (including
both), we'd have to write `x1..(x2 + 1)`. But we want to make sure
each room is enclosed in a wall, so we want to go from `x1` to `x2`
*exclusive*. To do that, we add 1 to the first coordinate and subtract
one from the second, ending up with `(x1 + 1)..x2`. If `x1` is `1` and
`x2` is `5`, we would put empty tiles at positions `2`, `3` and `4`
and leave `1` and `5` solid.

To test it, place two rooms in `make_map`:

[source,rust]
----
fn make_map() -> Map {
    // fill map with "blocked" tiles
    let mut map = vec![vec![Tile::wall(); MAP_HEIGHT as usize]; MAP_WIDTH as usize];

    // create two rooms
    let room1 = Rect::new(20, 15, 10, 15);
    let room2 = Rect::new(50, 15, 10, 15);
    create_room(room1, &mut map);
    create_room(room2, &mut map);

    map
}
----

Before testing it out, make the player appear in the centre of the
first room:

[source,rust]
----
let player = Object::new(25, 23, '@', colors::WHITE);
----

You can walk around the first room, but not reach the second. Let's
add a function to carve a horizontal tunnel:

[source,rust]
----
fn create_h_tunnel(x1: i32, x2: i32, y: i32, map: &mut Map) {
    for x in cmp::min(x1, x2)..(cmp::max(x1, x2) + 1) {
        map[x as usize][y as usize] = Tile::empty();
    }
}
----

We use `min` and `max` to make sure the `..` range always starts with
the smaller of the numbers -- it wouldn't return produce values
otherwise. What it all means that calling `create_h_tunnel(1, 5, ...)`
is equal to `create_h_tunnel(5, 1, ...)`.

And similarly for the vertical tunnels:

[source,rust]
----
fn create_v_tunnel(y1: i32, y2: i32, x: i32, map: &mut Map) {
    for y in cmp::min(y1, y2)..(cmp::max(y1, y2) + 1) {
        map[x as usize][y as usize] = Tile::empty();
    }
}
----

Now we can connect both rooms with a horizontal tunnel. In `make_map`:

[source,rust]
----
create_h_tunnel(25, 55, 23, &mut map);
----

Here's link:part-3a-building-blocks.rs[the code for this part].

== Dungeon generator

Here's link:part-3b-dungeon-generator.rs[the complete code so far].

Continue to <<part-4-fov-exploration#,the next part>>.
