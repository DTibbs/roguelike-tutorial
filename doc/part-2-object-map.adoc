= The object and the map
:source-highlighter: pygments
ifdef::env-github[:outfilesuffix: .adoc]

== Off-screen consoles

Before we continue, let's talk about _consoles_. In libtocd, console
is where we _draw stuff_. We've only used one so far -- the root
console. It is connected to the game window and anything you want to
show must eventually make its way there.

We can, however, create so-called _offscreen consoles_ and draw things
on them. Doing so will let us add transparency effects or only
render a portion of the console. It will also let us stack GUI windows
on top of the main game, render the info panel and the map
separately, etc.

From now on, we will draw to offscreen consoles and then compose them
into the root. It will occupy the whole screen for now.

Put this right after we initialise the root console:

[source,rust]
----
let mut con = Offscreen::new(SCREEN_WIDTH, SCREEN_HEIGHT);
----

Now call the `set_default_foreground` and `put_char` methods on `con`
instead of `root`.

And finally, blit the contents of the new console to the root console
to display them. The `blit` function takes a lot of parameters, but
the meaning is straight forward. We take the console we want to blit
_from_ (i.e. `con`), the coordinates where to start and the width and
height of the area we want to blit (we'll blit it all). Then the
destination (`root`), _where_ to start blitting (we'll use the
top-left corner) and finally a foreground and background transparency
(`0.0` is fully transparent, `1.0` completely opaque).

[source,rust]
----
blit(&mut con, (0, 0), (SCREEN_WIDTH, SCREEN_HEIGHT), &mut root, (0, 0), 1.0, 1.0);
----


== Generalising

Now that we have the `@` walking around, it would be a good idea to
step back and think a bit about the design. Having variables for the
player's coordinates is easy, but it can quickly get out of control
when you're defining things such as HP, bonuses, and inventory. We're
going to take the opportunity to generalize a bit.

Now, there can be such a thing as over-generalization, but we'll try
not to fall in that trap. What we're going to do is define the player
as a game `Object`. It will hold all position and display information
(character and color). The neat thing is that the player will just be
one instance of the `Object` struct -- it's general enough that you
can re-use it to define items on the floor, monsters, doors, stairs;
anything representable by a character on the screen. Here's the class,
with the initialization, and three common methods `move_by`, `draw`
and `clear`. The code for drawing and erasing is the same as the one
we used for the player earlier.

[source,rust]
----
struct Object {
    x: i32,
    y: i32,
    char: char,
    color: Color,
}

impl Object {
    pub fn new(x: i32, y: i32, char: char, color: Color) -> Self {
        Object {
            x: x,
            y: y,
            char: char,
            color: color,
        }
    }

    pub fn move_by(&mut self, dx: i32, dy: i32) {
        // move by the given amount
        self.x += dx;
        self.y += dy;
    }

    /// set the color and then draw the character that represents this object at its position
    pub fn draw(&self, con: &mut Console) {
        con.set_default_foreground(self.color);
        con.put_char(self.x, self.y, self.char, BackgroundFlag::None);
    }

    /// Erase the character that represents this object
    pub fn clear(&self, con: &mut Console) {
        con.put_char(self.x, self.y, ' ', BackgroundFlag::None);
    }
}
----

Now, before the main loop, we will create an actual player `Object`.
We will also add it to an array that will hold all objects in the
game. While we're at it, we'll add a yellow `@` that represents a
non-player character to test things out:

[source,rust]
----
let player = Object::new(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, '@', colors::WHITE);
let npc = Object::new(SCREEN_WIDTH / 2 - 5, SCREEN_HEIGHT / 2, '@', colors::YELLOW);
let mut objects = [player, npc];
----

Now we'll need to do a few changes to make it work. First in
`handle_keys` we'll use player's `move_by` method to change the
coordinates. This means we'll need to pass (mutable reference to) the
player object in.

[source,rust]
----
fn handle_keys(root: &mut Root, player: &mut Object) -> bool {
    // ...
}
----

and update the way we call it:

[source,rust]
----
let player = &mut objects[0];
let exit = handle_keys(&mut root, player);
----

Next, the main loop will now clear all objects like this:

[source,rust]
----
for object in &objects {
    object.clear(&mut con)
}
----

and draw them like so:

[source,rust]
----
for object in &objects {
    object.draw(&mut con);
}
----

And that's it! We have a fully generic object system. Later we can
modify this to have all the info items, monsters and anything else
will require.


Here's link:part-2a-generalising.rs[the code so far].

== The Map




Here's link:part-2b-map.rs[the complete code so far].

Continue to <<part-3-dungeon#,the next part>>.
