= The GUI
:icons: font
:source-highlighter: pygments
:source-language: rust
ifdef::env-github[:outfilesuffix: .adoc]

<<index#,Back to the index.>>

== Status bars

Lots of stuff happens under the hood of a game that players don't
really appreciate, like the combat mechanics detailed in the last
couple of sections. We'll now work on something much more flashy --
the Graphical User Interface! Using the full power of libtcod's
true-color consoles, and a bit of creativity, you can make some truly
amazing graphics. You may argue that the limitations of a console
actually make it easier to create a polished game, rather than if you
had the freedom to position per-pixel graphics like most other games.

We'll start by creating a GUI panel at the bottom of the screen. Of
course, you're welcome to change this to suit your taste. For now, it
will hold the player's health bar and a colored message log.

It's easier to manage GUI windows and panels with an off-screen
console for each one, created before the main loop:

[source]
----
let mut panel = Offscreen::new(SCREEN_WIDTH, PANEL_HEIGHT);
----

The constant PANEL_HEIGHT is defined later, along with others. Let's
jump right to the "status bar" rendering code! This is fully generic
and can be used for experience bars, mana bars, recharge times,
dungeon level, you name it.

The bar has two parts, one rectangle that changes size according to
the proportion between the value and the maximum value, and a
background rectangle. It just takes a simple formula to calculate that
size, and a few calls to tcod's `rect` method for the rectangles.

[source]
----
fn render_bar(panel: &mut Offscreen,
              x: i32,
              y: i32,
              total_width: i32,
              name: &str,
              value: i32,
              maximum: i32,
              bar_color: Color,
              back_color: Color)
{
    // render a bar (HP, experience, etc). First calculate the width of the bar
    let bar_width = (value as f32 / maximum as f32 * total_width as f32) as i32;

    // render the background first
    panel.set_default_background(back_color);
    panel.rect(x, y, total_width, 1, false, BackgroundFlag::Screen);

    // now render the bar on top
    panel.set_default_background(bar_color);
    if bar_width > 0 {
        panel.rect(x, y, bar_width, 1, false, BackgroundFlag::Screen);
    }
}
----

For extra clarity, the actual value and maximum are displayed as text
over the bar, along with a caption ('Health', 'Mana', etc). Put this
at the very end of `render_bar`:

[source]
----
// finally, some centered text with the values
panel.set_default_foreground(colors::WHITE);
panel.print_ex(x + total_width / 2, y, BackgroundFlag::None, TextAlignment::Center,
               &format!("{}: {}/{}", name, value, maximum));
----

Now we'll modify the main rendering function to use this. First,
define a few constants: the height of the panel, its position on the
screen (it's a bottom panel so only the Y is needed) and the size of
the health bar.

[source]
----
// sizes and coordinates relevant for the GUI
const BAR_WIDTH: i32 = 20;
const PANEL_HEIGHT: i32 = 7;
const PANEL_Y: i32 = SCREEN_HEIGHT - PANEL_HEIGHT;
----

We also changed `MAP_HEIGHT` to `43` to give the panel more room.

At the end of `render_all`, replace the code that shows the player's
stats as text with the following code. It re-initializes the panel to
black, calls our `render_bar` function to display the player's health,
then shows the panel on the root console.

[source]
----
// prepare to render the GUI panel
panel.set_default_background(colors::BLACK);
panel.clear();

// show the player's stats
let hp = objects[PLAYER].fighter.map_or(0, |f| f.hp);
let max_hp = objects[PLAYER].fighter.map_or(0, |f| f.max_hp);
render_bar(panel, 1, 1, BAR_WIDTH, "HP", hp, max_hp, colors::LIGHT_RED, colors::DARKER_RED);

// blit the contents of `panel` to the root console
blit(panel, (0, 0), (SCREEN_WIDTH, PANEL_HEIGHT), root, (0, PANEL_Y), 1.0, 1.0);
----

And we'll have to add `panel` to the `render_all` arguments and pass
it in from `main`.

== The message log

Until now the combat messages were dumped in the standard console --
not very user-friendly. We'll make a nice scrolling message log
embedded in the GUI panel, and use colored messages so the player can
know what happened with a single glance. It will also feature
word-wrap!

The constants that define the message bar's position and size are:

[source]
----
const MSG_X: i32 = BAR_WIDTH + 2;
const MSG_WIDTH: i32 = SCREEN_WIDTH - BAR_WIDTH - 2;
const MSG_HEIGHT: usize = PANEL_HEIGHT as usize - 1;
----

This is so it appears to the right of the health bar, and fills up the
rest of the space. The messages will be stored in a vector so they can
be easily manipulated. Each message is a tuple with 2 fields: the
message string, and its color.

[source]
----
// create the list of game messages and their colors, starts empty
let mut messages = vec![];
----

The type of that vector will be `Vec<(String, Color)>`. We'll be
passing it to a lot of our functions, so let's make an alias for it:

[source]
----
type Messages = Vec<(String, Color)>;
----


Now we add a function to add messages to the list:

[source]
----
fn message<T: Into<String>>(messages: &mut Messages, message: T, color: Color) {
    // if the buffer is full, remove the first message to make room for the new one
    if messages.len() == MSG_HEIGHT {
        messages.remove(0);
    }
    // add the new line as a tuple, with the text and the color
    messages.push((message.into(), color));
}
----

As new messages come in, we remove the old ones to make sure we always
fit into `MSG_HEIGHT`.

The `<T: Into<String>>` bit makes this function _generic_. Instead of
accepting a parameter of a specified type, it can work with anything
that implements the `Into` trait for `String`, i.e. anything that can
be converted to `String`. This lets us pass both `&str` (and therefore
string literals) and `String` (an output of the `format!` macro among
other things).

NOTE: The original tutorial uses the `textwrap` module in
Python's standard library to split the text into multiple lines based
on the maximum length. Rust's standard library doesn't have such a
function, but we can use libtcod's `get_height_rect` and
`print_rect` to do the wrapping for us.

To show the messages, we go through them one by one, get the height of
each (potentially line-wrapped) and draw them onto the panel using the
`print_rect` method.

[source]
----
// print the game messages, one line at a time
let mut y = MSG_HEIGHT as i32;
for &(ref msg, color) in messages.iter().rev() {
    let msg_height = panel.get_height_rect(MSG_X, y, MSG_WIDTH, 0, msg);
    y -= msg_height;
    if y < 0 {
        break;
    }
    panel.set_default_foreground(color);
    panel.print_rect(MSG_X, y, MSG_WIDTH, 0, msg);
}
----

We're going through the messages backwards (starting with the last
message), because we don't know if we get to print all. So we first
calculate the height of the message (in case it gets wrapped), we draw
it at the corresponding `y` position by subtracting the height and
then repeat.

When we have `y` lower than zero, it would mean we'd draw *above* the
panel. Libtcod wouldn't let us, but since that means we've ran out of
space, why we may as well break out of the loop.

Again, we need to pass the messages argument to `render_all`. It's
signature is now:

[source]
----
fn render_all(root: &mut Root, con: &mut Offscreen, panel: &mut Offscreen,
              objects: &[Object], map: &mut Map, messages: &Messages,
              fov_map: &mut FovMap, fov_recompute: bool)
----


And in the `main` loop:

[source]
----
render_all(&mut root, &mut con, &mut panel,
           &objects, &mut map, &messages,
           &mut fov_map, fov_recompute);
----

But now we're ready to test it! Let's print a friendly message before
the main loop to welcome the player to our dungeon of doom:

[source]
----
// a warm welcoming message!
message(&mut messages, "Welcome stranger! Prepare to perish in the Tombs of the Ancient Kings.",
        colors::RED);
----

Yay! You can now replace all the `println!` macro uses with calls to
our own `message` function (all four of them). The player death
message is red (`colors::RED`), monster death is orange
(`colors::ORANGE`) and the rest is `colors::WHITE`.

Unfortunately, to display messages, we have to pass the `messages:
&mut Messages` vector everywhere we want to print a message (which is
pretty much everywhere).

As usual, just replace the `println!(...)` calls with `message(...)`
and let the compiler guide you.

:lazy_static: https://crates.io/crates/lazy_static/

NOTE: This is quite annoying and you may think about using global
variables or the _singleton_ pattern to ease the pain. If you want to
go that route, you may want to check out the {lazy_static}[lazy_static
crate]. But if you persist a while longer, we'll collapse all these
separate variables into three structs that are much easier to pass
around.


== Mouse-look


Here's link:part-7-gui.rs[the complete code so far].

Continue to <<part-8-items#,the next part>>.
