= Adventure gear
:icons: font
:source-highlighter: pygments
:source-language: rust
ifdef::env-github[:outfilesuffix: .adoc]


<<index#,Back to the index.>>


So now we have a dungeon full of monsters and scrolls, but it's still
somewhat lacking in variety. Where are all the swords, shields, staves
and so on?

We need equipment. It differs from the items we have in two ways: you
can only equip it in limited slots and it enhances your abilities
while it's being worn. Unlike our items which are one-use-only (though
they don't have to be!).

== Basic equipment

Let's create an `Equipment` component. It will know whether it's
equipped or not and it will also have a `slot` such as "hand" for
weapons or "head" for helmets.

[source]
----
#[derive(Clone, Copy, Debug, PartialEq, RustcDecodable, RustcEncodable)]
/// An object that can be equipped, yielding bonuses.
struct Equipment {
    slot: Slot,
    equipped: bool,
}

#[derive(Clone, Copy, Debug, PartialEq, RustcDecodable, RustcEncodable)]
enum Slot {
    LeftHand,
    RightHand,
    Head,
}
----

NOTE: We're using `enum` for the equipment slots to stay safe from
typos and forgetting to handle a new case in a `match`. You can just
use a string instead, though.

We'll add this new component to our `Object` and its `new` method:

[source]
----
struct Object {
    ...
    equipment: Option<Equipment>,
}


impl Object {
    pub fn new(x: i32, y: i32, char: char, name: &str, color: Color, blocks: bool) -> Self {
        Object {
            ...
            equipment: None,
        }
    }
    ...
}
----

And let's add a couple of new `Object` methods for putting the
equipment on and off:

[source]
----
/// Equip object and show a message about it
pub fn equip(&mut self, log: &mut Vec<(String, Color)>) {
    if self.item.is_none() {
        log.add(format!("Can't equip {:?} because it's not an Item.", self),
                colors::RED);
        return
    };
    if let Some(ref mut equipment) = self.equipment {
        if !equipment.equipped {
            equipment.equipped = true;
            log.add(format!("Equipped {} on {:?}.", self.name, equipment.slot),
                    colors::LIGHT_GREEN);
        }
    } else {
        log.add(format!("Can't equip {:?} because it's not an Equipment.", self),
                colors::RED);
    }
}
----

The meat of the method is in its middle: we take the equipment
component, mark its `equipped` value as true and print a message. The
checks before and after are there to make sure that the `Object` we're
calling is indeed an `Equipment` and also an `Item`.

We could just ignore that since all equipments should be items (i.e.
they can be carried in the inventory and dropped on the floor), it's
better to see when the unexpected happens.

Dequip works similarly:

[source]
----
/// Dequip object and show a message about it
pub fn dequip(&mut self, log: &mut Vec<(String, Color)>) {
    if self.item.is_none() {
        log.add(format!("Can't dequip {:?} because it's not an Item.", self),
                colors::RED);
        return
    };
    if let Some(ref mut equipment) = self.equipment {
        if equipment.equipped {
            equipment.equipped = false;
            log.add(format!("Dequipped {} from {:?}.", self.name, equipment.slot),
                    colors::LIGHT_YELLOW);
        }
    } else {
        log.add(format!("Can't dequip {:?} because it's not an Equipment.", self),
                colors::RED);
    }
}
----

NOTE: You may have noticed that we're passing the message log
(`Vec<(String, Color)>`) directly instead of the full `Game` struct
like in other `Object` methods such as `attack` or `take_damage`. This
is to avoid a double mutable borrow later. Try passing `game: &mut
Game` here instead and you'll see the problem when we get to
`toggle_equip`.

How do we equip our items? We can rely on the existing `Item`
mechanism -- when you try to "use" or "cast" an equipment (which you
can do since it's an `Item`, too), we'll equip or dequip it.

First, let's add a new Item type:

[source]
----
enum Item {
    Heal,
    Lightning,
    Confuse,
    Fireball,
    Equipment,
}
----

NOTE: We'll just group all equipments under a single item type. We can
always split them out later.

Then in the callback match in `use_item`:

[source]
----
let on_use: ... = match item {
    Heal => cast_heal,
    Lightning => cast_lightning,
    Fireball => cast_fireball,
    Confuse => cast_confuse,
    Equipment => toggle_equipment,
}
----

We have to create the `toggle_equipment` function:

[source]
----
fn toggle_equipment(inventory_id: usize, _objects: &mut [Object], game: &mut Game, _tcod: &mut Tcod)
             -> UseResult
{
    let equipment = match game.inventory[inventory_id].equipment {
        Some(equipment) => equipment,
        None => return UseResult::Cancelled,
    };
    if equipment.equipped {
        game.inventory[inventory_id].dequip(&mut game.log);
    } else {
        game.inventory[inventory_id].equip(&mut game.log);
    }
    UseResult::UsedAndKept
}
----

We're returning a new `UseResult` value here: one that says we have
used the item (so it's the monsters' turn now), but we don't want the
item to disappear!

NOTE: Here is why we have to pass `&mut game.log` to `equip` instead
of the full `&mut game`: in the same statement we look up the
equipment Object in `game.inventory`, which will make `game` mutably
borrowed for the duration of the `equip` call. So we can't borrow it
second time. However, since we're only borrowing `game.inventory`, we
_can_ borrow `game.log` separately! If you don't like this, you could
turn the `equip` and `dequip` methods into standalone functions that
would take `inventory_id` and `&mut game`.

We need to add the new value to the `UseResult` enum and handle the
new case in `use_item` (as always, the compiler will complain so you
can rely on it to tell you where to look):

[source]
----
match on_use(inventory_id, objects, game, tcod) {
    UseResult::UsedUp => {
        ...
    }
    UseResult::UsedAndKept => {}, // do nothing
    UseResult::Cancelled => {
        ...
    }
}
----

And hey! Now we can have regular items that don't disappear upon use
-- such as wands, spellbooks, lockpicks, etc.

Finally, we need to update the item chances for this new
`Equipment` type and add one to the game!

Add this to the `item_chances` in `place_objects`:

[source]
----
Weighted {weight: 1000, item: Item::Equipment},
----

And then this sword later on where we generate the items:

[source]
----
Item::Equipment => {
    // create a sword
    let mut object = Object::new(x, y, '/', "sword", colors::SKY, false);
    object.item = Some(Item::Equipment);
    object.equipment = Some(Equipment{equipped: false, slot: Slot::RightHand});
    object
}
----

As you can see, the weighted chances really don't have to be
percentages. By setting the sword's value to `1000`, it's much more
likely to appear than any other item so we can find it early in the game
and test it!

We will set it back to something more reasonable later on.


== Equipment polish

Now that we have the equipment basics in place, let's finish it up.
First, we only want to have one item equipped in any given slot.
Here's a function that returns an equipment that occupies a given slot
(if it exists):

[source]
----
fn get_equipped_in_slot(slot: Slot, inventory: &[Object]) -> Option<usize> {
    for (inventory_id, item) in inventory.iter().enumerate() {
        if item.equipment.as_ref().map_or(false, |e| e.equipped && e.slot == slot) {
            return Some(inventory_id)
        }
    }
    None
}
----

We can use it to prevent a second item in the same slot, or better
yet: dequip the old item to make room for the new one. In
`toggle_equipment`:

[source]
----
// if the slot is already being used, dequip whatever is there first
if let Some(old_equipment) = get_equipped_in_slot(equipment.slot, &game.inventory) {
    game.inventory[old_equipment].dequip(&mut game.log);
}
----

Another nice behavior is to automatically equip picked up items, if
their slots are available. In the `pick_item_up` function, in the
`else` branch:

[source]
----
let item = objects.swap_remove(object_id);
game.log.add(format!("You picked up a {}!", item.name), colors::GREEN);
let index = game.inventory.len();
let slot = item.equipment.map(|e| e.slot);
game.inventory.push(item);

// automatically equip, if the corresponding equipment slot is unused
if let Some(slot) = slot {
    if get_equipped_in_slot(slot, &game.inventory).is_none() {
        game.inventory[index].equip(&mut game.log);
    }
}
----

We take the inventory index of the picked up item and an `Option` of
the equipment slot (it's `None` if the item is not an equipment).

Then we check whether that slot is occupied, and if not, equip the new
item.

We also need to de-equip an item if we're dropping it. In `drop_item`
right after the `game.inventory.remove` line:

[source]
----
if item.equipment.is_some() {
    item.dequip(&mut game.log);
}
----

It would also be nice if we could show which items are equipped in the
inventory screen. Replace the `inventory.iter().map(...)` line in
`inventory_menu` with:

[source]
----
inventory.iter().map(|item| {
    // show additional information, in case it's equipped
    match item.equipment {
        Some(equipment) if equipment.equipped => {
            format!("{} (on {:?})", item.name, equipment.slot)
        }
        _ => item.name.clone()
    }
}).collect()
----

We just replace the closure passed to `map` to report the equipped
slot if available and the item name otherwise.

You can check the equipment's state in the inventory screen, and it
changes correctly as you pick up, drop, equip and dequip various
items!

One last thing to do here: the message log shows the equipment slot as
capitalised:

----
Equipped sword on RightHand.
----

This is because the slots are enums and this is their `Debug`
representation -- if they didn't have `#[derive(Debug)]`, we wouldn't
be able to print them at all.

It would be nice if we could override the output somehow. Or better
yet, leave the debug output as is but provide a human-readable
alternative!

:display: https://doc.rust-lang.org/std/fmt/trait.Display.html

The way to provide a user facing output in Rust is to implement the
{display}[Display] trait.

Let's give it a go:

[source]
----
impl std::fmt::Display for Slot {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match *self {
            Slot::LeftHand => write!(f, "left hand"),
            Slot::RightHand => write!(f, "right hand"),
            Slot::Head => write!(f, "head"),
        }
    }
}
----

The `write!` macro is similar to `format!` or `println!` but it writes
to a `std::fmt::Formatter` struct.

We can now use this new formatting by replacing `{:?}` to `{}` every
time we print out a `Slot`. So in `inventory_menu`:

[source]
----
format!("{} (on {})", item.name, equipment.slot)
----

and then the "Equipped on" and "Dequipped on" messages in `equip` and `dequip`.

And now the equipment-related messages look much nicer!

== Bonus round

The last bit is to make equipment useful, by letting it change the
player's stats when equipped. We could simply add the bonus value to a
stat (say, attack power) when the item is equipped, and subtract it
when dequipped. This is brittle because any tiny mistake will
permanently change the player's stats!

A more reliable approach is to calculate on-the-fly the player's stats
when they are needed, based on the original stat and any bonuses. This
way there's no room for inconsistencies -- the stat is truly based on
whatever bonuses apply at the moment.

Other languages have different ways of dealing with this (e.g.
Python's properties), but in Rust we have to rely on functions and
methods.




Here's link:part-13-adventure-gear.rs.txt[the complete code].
