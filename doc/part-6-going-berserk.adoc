= Going Berserk!
:icons: font
:source-highlighter: pygments
:source-language: rust
ifdef::env-github[:outfilesuffix: .adoc]

<<index#,Back to the index.>>

== The Components

TODO: talk about composition vs. inhericance and how this isn't a real ECS whatever that means...

Our components will be plain `structs` with related bits of data and
not much else. Each `Object` will have some (or all or none) of the
components attached and that will drive their behaviour. Only things
with the `Fighter` component will be able to attack or be attacked,
etc..

Let's create the `Fighter` component. It will have hit points, maximum
hit points (for healing), defense and attack power.

[source]
----
// combat-related properties and methods (monster, player, NPC).
#[derive(Clone, Copy, Debug, PartialEq)]
struct Fighter {
    max_hp: i32,
    hp: i32,
    defense: i32,
    power: i32,
}
----

Next is the component for monster artificial intelligence. For now, it
will not carry any data, but we'll soon remedy that.

[source]
----
#[derive(Clone, Copy, Debug, PartialEq)]
struct Ai;
----

And update the `Object` definition:

[source]
----
fighter: Option<Fighter>,
ai: Option<Ai>,
----

and `Object::new`:

[source]
----
fighter: None,
ai: None,
----

This means that the newly-created objects will not have any
components. We can add them ourselves, though!

First the player:

[source]
----
player.fighter = Some(Fighter{max_hp: 30, hp: 30, defense: 2, power: 5});
----

(you'll need to make the `player` variable mutable because we're
changing it now)


And next the monsters. Each monster will get a `Fighter` component as
well as the `Ai` one. In `place_objcets` where the monsters are
defined:

[source]
----
if ... {
    // create an orc
    let mut orc = Object::new(x, y, 'o', "orc", colors::DESATURATED_GREEN, true);
    orc.fighter = Some(Fighter{max_hp: 10, hp: 10, defense: 0, power: 3});
    orc.ai = Some(Ai);
    orc
} else {
    // create a troll
    let mut troll = Object::new(x, y, 'T', "troll", colors::DARKER_GREEN, true);
    troll.fighter = Some(Fighter{max_hp: 16, hp: 16, defense: 1, power: 4});
    troll.ai = Some(Ai);
    troll
}
----

== AI

We went through all this trouble and yet nothing happens? Let's that
by actually using our newly-minted components! The monsters have been
growling for too long and are ready to fight now.

We'll start by creating a function that will cause an object (monster,
usually) move towards a position (the player's coordinates, usually).

[source]
----
fn move_towards(id: usize, target_x: i32, target_y: i32, map: &Map, objects: &mut [Object]) {
    // vector from this object to the target, and distance
    let dx = target_x - objects[id].x;
    let dy = target_y - objects[id].y;
    let distance = ((dx.pow(2) + dy.pow(2)) as f32).sqrt();

    // normalize it to length 1 (preserving direction), then round it and
    // convert to integer so the movement is restricted to the map grid
    let dx = (dx as f32 / distance).round() as i32;
    let dy = (dy as f32 / distance).round() as i32;
    move_by(id, dx, dy, map, objects);
}
----

Next we'll add a method on `Object` that will tell us the distance to
another object.

[source]
----
/// return the distance to another object
pub fn distance_to(&self, other: &Object) -> f32 {
    let dx = other.x - self.x;
    let dy = other.y - self.y;
    ((dx.pow(2) + dy.pow(2)) as f32).sqrt()
}
----

All right, let's use them to implement some basic behaviour: if the
monster is close, it will attack, otherwise it will move closer.

[source]
----
fn ai_take_turn(monster_id: usize, map: &Map, objects: &mut [Object], fov_map: &FovMap) {
    // a basic monster takes its turn. If you can see it, it can see you
    let (monster_x, monster_y) = objects[monster_id].pos();
    if fov_map.is_in_fov(monster_x, monster_y) {
        if objects[monster_id].distance_to(&objects[PLAYER]) >= 2.0 {
            // move towards player if far away
            let (player_x, player_y) = objects[PLAYER].pos();
            move_towards(monster_id, player_x, player_y, map, objects);
        } else if objects[PLAYER].fighter.map_or(false, |f| f.hp > 0) {
            // close enough, attack! (if the player is still alive.)
            let monster = &objects[monster_id];
            println!("The attack of the {} bounces off your shiny metal armor!", monster.name);
        }
    }
}
----

But for any of this to have effect, we need to call it from the main
loop:

[source]
----
for id in 0..objects.len() {
    if objects[id].ai.is_some() {
        ai_take_turn(id, &map, &mut objects, &fov_map);
    }
}
----

When you test it now, you can see the monsters following you around
and trying to attack you.

The whole code is available link:part-6a-ai.rs[here].

== Sword-fighting

== Untimely deaths

Here's link:part-6b-untimely-deaths.rs[the complete code so far].


Continue to <<part-7-gui#,the next part>>.
